<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <link rel="stylesheet" href="style.css"/>
        <script src="https://d3js.org/d3.v5.min.js"></script>
        <script src="GrahamScan.js"></script>
        <script src="GiftWrapping.js"></script>
        <script src="Triangulation.js"></script>
        <script src="KdTree.js"></script>
        <script src="Edge.js"></script>
        <script src="Triangle.js"></script>
        <script src="Delaunay.js"></script>
        <script src="Utils.js"></script>
        <script src="Voronoi.js"></script>
        <style>
            body {
                margin: auto;
                position: relative;
            }
            button {
                /* position: relative;
                float: right; */
            }
            .container {
                position: relative;
                float: right;
                height: 100px;
                width: 550px;
                background-color: white
            }
        </style>
    </head>
    <body>
        <div class="container">
            <button type="button" onclick=generateRandomPoints()>Generate Random Points</button>
            <button type="button" onclick=clearCanvas()>Clear Canvas</button>
            <button type="button" onclick=giftWrapping2()>Gift Wrapping</button>
            <button type="button" onclick=grahamScan()>Graham Scan</button>
            <button type="button" onclick=createKDTree()>K-D tree</button>
            <button type="button" onclick=triangulation()>Triangulation</button>
            <button type="button" onclick=delaunayTriangulation()>Delaunay</button>
            <button type="button" onclick=voronoiDiagram()>voronoi</button>

        </div>
    </body>
    <script>

        const margin = {
            top: 40,
            bottom: 10,
            left: 20,
            right: 20
        };
        const bodyWidth = 1000;
        const bodyHeight = 450;
        const radius = 5;
        var edges = [];
        var points = [];
        var resultLine = [];
        var stack = [];
        var ael = [];
        var dt = [];
        var bestCircle = null;
        var newPoint = null;
        var noPoint = null;
        var triangles = [];

        var xScale = d3.scaleLinear().range([0,bodyWidth])
            .domain([0,bodyWidth]);
        var yScale = d3.scaleLinear().range([0,bodyHeight])
            .domain([0,bodyHeight]);
        

        var svg = d3.select('body')
            .append('svg')
            .attr('width', bodyWidth)
            .attr('height', bodyHeight)
            .style('margin', '40px')
            .style('border', '1px solid black');
            
        var drag = d3.drag()
            .subject(function(d) {return d;})
            .on('start', dragstarted)
            .on('drag', dragmove)
            .on('end', dragended);

        svg.on('click', function(){
            if (d3.event.defaultPrevented) return;
            let mouse = d3.mouse(this);
            point = {
                x: Math.round(xScale(mouse[0])),
                y: Math.round(yScale(mouse[1])),
            }
            points.push(point);         
            console.log('click ', point);

            svg.selectAll("circle")
                .data(points)
                .enter()
                .append('circle')                
                .attr('r',radius)
                .attr('cx', function(d) {return xScale(d.x) })
                .attr('cy', function(d) {return yScale(d.y) })
                .on('contextmenu', handleDeleteRightClick)
                // .on("mouseover", handleMouseOver)
                // .on("mouseout", handleMouseOut)
                .call(drag);
        })

        function handleDeleteRightClick(d, i) {
            d3.event.preventDefault();
            d3.select(this).remove();
            points.pop(i);         
        }

        function generateRandomPoints(){
            let tmpPoint = {};
            for (let i = 0; i < 5; i++) {
                tmpPoint = {
                    x: Math.round(xScale(Math.random() * (bodyWidth - radius * 2) + radius)),
                    y: Math.round(xScale(Math.random() * (bodyHeight - radius * 2) + radius)),
                }
                points.push(tmpPoint);                
            }

            svg.selectAll("circle")
                .data(points)
                .enter()
                .append('circle')                
                .attr('r',radius)
                .attr('cx', function(d) {return xScale(d.x) })
                .attr('cy', function(d) {return yScale(d.y) })
                .on('contextmenu', handleDeleteRightClick)
                // .on("mouseover", handleMouseOver)
                // .on("mouseout", handleMouseOut)
                .call(drag);
        }


        function clearCanvas(){
            points = [];
            stack = [];
            d3.select('svg').selectAll('*').remove();
        }

        function clearLines(){
            resultLine = [];
            d3.select('svg').selectAll('line').remove();
        }

        function dragstarted(d) {
            d3.event.sourceEvent.stopPropagation();
            console.log('drag started ',d[0],' ',points);
            d3.select(this).raise().attr('fill', 'green');
        }

        function dragmove(d) {
            d3.select(this).attr('cx', d.x = d3.event.x).attr('cy', d.y = d3.event.y);
        }

        function dragended(d) {
            d3.select(this).attr('fill', 'black');
            console.log('drag ended ',d[0],' ',points);
        }

        // Create Event Handlers for mouse NOT WORKING
        function handleMouseOver(d, i) {  // Add interactivity
            //!!NOT WORKING
            console.log(d,i);
            // Use D3 to select element, change color and size
            // d3.select(this).attr({
            //   fill: "orange",
            //   r: radius * 2
            // });

            // Specify where to put label of text
            svg.append("text").attr({
            id: "t" + d.x + "-" + d.y + "-" + i,  // Create an id for text so we can select it later for removing on mouseout
                x: function() { return xScale(d.x) - 30; },
                y: function() { return yScale(d.y) - 15; }
            })
            .text(function() {
            return [d.x, d.y];  // Value of the text
            });
        }

        function handleMouseOut(d, i) {
            //!!NOT WORKING
            console.log(d,i);

            // Use D3 to select element, change color back to normal
            d3.select(this).attr({
            fill: "black",
            r: radius
            });

            // Select text by id and then remove
            d3.select("#t" + d.x + "-" + d.y + "-" + i).remove();  // Remove text location
        }
       

        function drawLine(a,b){
            svg.append('line')
                    .style('stroke', 'black')
                    .attr('x1', xScale(a.x))
                    .attr('y1', xScale(a.y))
                    .attr('x2', xScale(b.x))
                    .attr('y2', xScale(b.y));
        }

        function drawCircle(c, color = 'red'){
            svg.append('circle')
                .attr('cx', xScale(c.center.x))
                .attr('cy', xScale(c.center.y))
                .attr('r', xScale(c.radius))
                .style('stroke',color)
                .style('fill','none');
        }

        function sortPoints(a,b){
            if(a.y < b.y) {return -1;}
            if(a.y > b.y) {return 1;}
            else {return 0;}
        }

        // function findPath(point,queue,end,path){
        //     let tmpP = point;
        //     edges.forEach(element => {
        //         if(tmpP === end){
        //             //queue.push(tmpP);
        //             return;
        //         }
        //         //leftPath - elementA === tmpP
        //         //rightPath - elementB === tmpP
        //         if(path === 0 && element.a === tmpP){
        //             queue.push(element.b);
        //             tmpP = element.b;
        //         }
        //         if(path === 1 && element.b === tmpP){
        //             queue.push(element.a);
        //             tmpP = element.a;
        //         }
        //     });
        // }

        // function checkPath(point,path){
        //     return path.find((element)=>{
        //         return element === point;
        //     })
        // }

        /*
        function triangulation(){
            grahamScan();
            console.log(points,stack, edges);
            
            //remove other points inside hull
            //remove lines
            //sort
            stack.sort(sortPoints);
            console.log(stack);
            let firstP = stack[0];
            let lastP = stack[stack.length-1];
            let leftPath = [];            
            let rightPath = [];
            let tmpPoint = null;
            let lineStack = [];
            
            edges.forEach(element => {
                if(element.a === firstP){
                    //left Path - because we go anticlockwise during graham scam
                    //so the first point(a) is the highest one and the second (b)
                    //is the lower
                    leftPath.push(element.a);
                    leftPath.push(element.b);
                    if(element.b !== lastP){findPath(element.b,leftPath,lastP,0)}
                }
                else if(element.b === firstP){
                    //right path - because the top point is point (b)
                    rightPath.push(element.b);
                    rightPath.push(element.a);
                    if(element.a !== lastP){findPath(element.a,rightPath,lastP,1)}
                }
                else{}
            });
            
            console.log('left: ',leftPath);
            console.log('right: ',rightPath);

            lineStack.push(stack[0]);
            lineStack.push(stack[1]);
            //we expect that we have correct convex hull
            let nextElem;
            let nextElemPath;
            let stackElemPath = checkPath(lineStack[1],rightPath);
            for (let i = 2; i < stack.length; i++) {
                
                nextElem = stack[i];
                
                //right - 1, left - 0
                nextElemPath = checkPath(nextElem,rightPath);

                console.log(lineStack[lineStack.length-1]);
                console.log(nextElem);
                console.log(nextElemPath);
                console.log(stackElemPath);

                if(nextElemPath === stackElemPath){
                    for (let i = lineStack.length - 1; i > 0; i--){
                        drawLine(nextElem,lineStack[i]);
                        lineStack.pop(i);
                    }
                    lineStack.push(nextElem);
                }
                else{
                    let top = lineStack[lineStack.length-1];
                    for (let i = lineStack.length - 1; i > 0; i--){
                        drawLine(nextElem,lineStack[i]);
                        lineStack.pop(i);
                    }
                    lineStack.push(top);
                    lineStack.push(nextElem);
                }
                stackElemPath = checkPath(lineStack[lineStack.length-1],rightPath);
            }
        }*/
    </script>
</html>